# 면접 질문 대비



## 네트워크

### OSI7계층, TCP/IP 프로토콜, URI를 입력했을 때 일어나는 일을 설명해주세요 (3way Handshake, 4 way Handshake 도 가능하면 함께요)

OSI7계층은 ISO에서 만든 공식적인 모델이고 이를 실제 사용할 땐 주로 TCP/IP 로 적용합니다.

통신 흐름은 제가 인터넷 주소창에 URI를 입력했다라고 가정하고 말씀드리겠습니다.

A 사이트의 주소를 입력하면 응용, 표현, 세션 계층에선 HTTP 메서드 데이터를 포함해 전송계층으로 보내줍니다.

전송계층의 역할은 크게 두 가지로 볼 수 있습니다. 

첫 번째로 서버와 우선 연결을 확인하기 위해 3 way Handshake로 연결을 해줍니다. 3 way handshake에서는 클라이언트가 SYN 요청을 보내고 서버가 요청에 대한 응답 ACK 와 서버도 클라이언트에 연결하기 위해 SYN 요청을 보내고 클라이언트는 ACK 요청으로 확답을 줘 연결됩니다. 이 연결통로를 통해 TCP 프로토콜의 패킷순서 및 전송 신뢰를 할 수 있습니다.

두 번째론 연결 후 어느 애플리케이션으로 가야할지 포트번호가 담긴 TCP 헤더를 추가해 네트워크 계층으로 내려갑니다.

네트워크 계층에선 출발지, 목적지 IP 주소가 담긴 IP 헤더가 붙어 IP 패킷이 데이터링크 계층으로 내려가고 데이터링크 계층에서 MAC 주소가 있는 이더넷 헤더가 추가되 이더넷 프레임이 물리계층으로 내려갑니다.

물리계층에선 비트신호가 전기신호로 변환되 전송됩니다. 전기신호는 서버에 도착하기 전 스위치와 라우터를 거칩니다.

전기신호는 다음 스위치까지 전달되 물리적주소인 MAC주소가 맞는지 데이터 링크 계층까지 언캡슐화해 확인하고 라우터에서는 IP주소를 확인해 맞다면 출발지 IP 주소를 라우터의 IP주소로 변경해 보내주는 네트워크 계층의 역할을 합니다.

이와 같은 과정을 거쳐 목적지 서버에 도착하고 서버에서 같은 과정들을 통해 출발지, 목적지가 뒤바뀐 후 다시 클라이언트로 돌아오게 됩니다.



### 4 Way Handshake에 대해 아시나요

3 Way Handshake와 반대로 연결을 끊는 4 Way Handshake는 클라이언트 FIN 요청을 보내면 서버가 ACK 응답 후 FIN 응답을 주고 클라이언트가 ACK 응답을 줘 연결을 안전한게 끊을 수 있습니다.

연결 과정과 한 단계가 차이나는 이유는 Client가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 때문이다.



### TCP/IP와 전송계층에 대해 같이 설명해주세요

IP 프로토콜만으로는 서버와 클라이언트의 연결이 제대로 되있는지, 패킷의 전송 순서가 맞는지를 확인할 수 없습니다. 이렇기 때문에 전송계층에서 클라이언트와 서버의 안정적인 통신을 위해 TCP를 통해 3 way handshake를 연결 통로를 확립해 데이터 전달 및 순서를 보증할 수 있습니다.



### TCP, UDP 는 뭘까요

TCP/UDP는 전송계층의 연결형/비연결형 통신 방법을 말합니다. 

TCP는 연결형 통신으로 3 Way HandShake를 통해 연결을 확립해놓고 통신을 하는 반면에 UDP는 비연결형 통신으로 일방적으로 보내기 때문에 오류 점검 및 연결확인은 못하지만 브로드캐스팅 같이 불특정 다수에게 보내는 통신으로 적합합니다. 

헤더의 차이로는 TCP 헤더는 연결 및 에러 확인 후 복구 같은 다양한 헤더가 있으며 UDP는 TCP에 비해 에러 확인 부부만 있기에 더 간단하다는 차이가 있습니다.



### DNS란 뭔가요?

보통 서버를 찾을 때 IP를 기억하거나, IP가 변경됬을 때 찾기가 어렵기 때문에 이런 상황에 대비해 Domain Name System을 도입해 Host의 Domain Name을 IP로 변환해 편하게 사용할 수 있게 해줍니다. Domain name, Ip를 저장하는 Host 파일은 SRI라 하는 기관에서 관리해 저희에게 Host 파일을 제공해 사용할 수 있습니다. 그러나 갈수록 주소가 많아지면서 Host 파일로만 감당할 수 없게 되어 DNS가 만들어지게 됬습니다.



작동방식으로는 다음과 같습니다.

0. 클라이언트는 우선 URI(도메인)을 검색하면 Host 파일에 있는지 확인하고 없으면 DNS로 요청을 보냅니다..

1. 브라우저에 URI를 입력해 Local DNS로 가 있다면 반환해주고 없으면 Root DNS로 갑니다.
2. Root DNS에도 없으면 더 상위 계층의 서버인 TLD(Top Level Domain) 한테 가서 URI의 IP주소를 반환받습니다.
3. 반환받은 IP주소를 Local DNS에게 주고 Local DNS는 다시 클라이언트한테 IP로 돌려주게 됩니다.

OSI 7계층과 연관지어 생각하면 Local Dns 에서 ip주소가 없다면 루트 DNS로 가서 네트워크 계층을 통해 ip 주소를 받아올 수 있습니다.



### DNS 서버의 종류

권한이 있는 DNS 서버와 권한이 없는 DNS 서버로 나뉘며 



### HTTP에 대해 설명해주시고 1.1과 2.0에 대해 설명해주세요

HTTP는 어플리케이션 계층 프로토콜의 한 종류로 TCP/IP 기반의 프로토콜이며 주로 브라우저간의 통신을 하기 위해 사용됩니다.

1.1에서는 기본적으로 연결 하나와 응답 하나로 처리하기 때문에 동시전송 및 다수의 리소스 처리는 속도가 느려지고 요청과 응답이 반복될수록 헤더가 무거워지는 단점이 있었습니다.

2.0에서는 이런 단점을 한 번에 여러개의 메시지를 주고 받을 수 있고 헤더 압축전송 방식을 도입해 기능을 향상시켰습니다. 아직 그러나 많은 곳에서 1.1을 사용하는 것으로 알고 있습니다.



### HTTP 메서드에 대해 설명해주세요

클라이언트와 서버간 데이터를 전송하고 받을 때 HTTP 프로토콜을 기반으로 동작합니다. 즉 모든 데이터들을 HTTP 프로토콜을 통해 통신합니다.

HTTP 메서드는 GET, POST, PUT, PATCH, DELETE가 있습니다.

GET은 데이터를 받아오고 메세지 바디가 없고

POST는 데이터를 보내는 것, 즉 게시물을 등록하는 것과 같은 작업,

PUT은 아예 덮어씌우는 것, 파일 첨부같을 때 사용하며

PATCH는 일부부만 변경하고 싶을 때, 

DELETE는 삭제할 때 사용합니다.



### HTTP 특징에 대해 설명해주세요

HTTP의 특징은 크게 두 가지가 있습니다.

첫 번째로 Stateless(무상태) 한 것입니다. stateless 하다는 것은 서버가 클라이언트를 누구인지 기억하지 않기 때문에 서버는 클라이언트가 로그인을 했는지, 주문을 하기 위해 장바구니에 뭘 담아놨는지를 기억하지 못하기 때문에 요청 데이터가 길어지는 단점이 있습니다.

두 번째로 connectless(비연결성) 입니다. 서버와 통신할 때 저희가 계속 연결되있는게 아니라 통신하는 그 순간에만 연결을 해 데이터를 받고 연결을 끊습니다.

이런 단점들이 있지만 stateful, connection 보다 사용하는 이유는 클라이언트가 연결이 되있는게 아니라 아니라 요청에 따라 응답을 하기 때문에 효율적이며 서버가 에러나도 요청에 따라 응답을 하기 때문에 문제가 없다는 장점들이 있기 때문에 사용합니다.



그 외의 HTTP 속성으로는 안전, 멱등, cashable이 있습니다.

- 안전(Safe Methods)
  - 호출해도 리소스를 변경하지 않는 것을 안전하다 함
  - GET은 조회만 하므로 변경하지 않으니까 안전함
  - POST, DELETE는 변경이 일어나니까 안전하지 않음
- 멱등(Idempotent Methods)
  - 한 번 호출하든 두 번 호출하든 결과가 같은 것 (f(x) == f(f(x)))
  - GET: 조회는 몇 번해도 결과가 같음(멱등)
  - PUT: 결과를 대체하므로 몇 번 같은 요청을 해도 결과가 같음(멱등)
  - DELETE: 삭제는 몇 번 삭제해도 삭제된 결과는 동일함(멱등)
  - POST: 멱등이 아님!! 주문 및 결제는 중복되면 2번 음식배달 옴
  - 멱등 활용법으로 자동 복구 매커니즘이 있음. 서버가 TIMEOUT되서 정상응답을 못 주면 클라이언트가 다시 같은 요청을 할 수 있도록 자동 복구 매커니즘 활용
  - 멱등하면서 중간에 리소스변경되면 결과가 다르지만 이러한 경우는 고려하지 않음
- 캐시가능(Cacheable Methods)
  - GET, HEAD만 캐시 가능
  - POST,P PATCH도 가능은 하지만 본문 내용까지 캐시 키로 구현해야 되는게 쉽지 않음





### HTTP와 HTTPS의 차이와 HTTPS의 보안에 대해 설명해주세요

HTTPS는 기존의 HTTP보다 Secure 보안이 추가된 것이며 추가된 보안의 기능은 다음과 같이 2가지가 있습니다.

첫 번째로 내가 서버에 보내는 요청들을 타인이 볼 수 없도록 암호화합니다.

두 번째론 내가 요청한 서버가 제대로 신뢰가 가는 서버인지 판별해줍니다.

보안의 원리로는 대칭키와 비대칭키, CA가 사용됩니다.

우선 클라이언트가 서버에 더미 데이터를 보내고, 서버에서도 더미데이터와 공개키가 포함된 인증서를 클라이언트에게 돌려줍니다. 

CA(Certificate Authority)의 인증을 받은 서버들의 개인키가 보관이 되기 때문에 공개키를 포함된 인증서가 만약 신뢰할만한 사이트라면 클라인트가 받은 인증서를 복호화해 서버의 공개키를 얻을 수 있습니다. 이와 같은 방법을 통해 앞서 말씀 드린 보안의 장점 중 한 가지인 서버가 인증할만한 사이트인것을 확인할 수 있습니다.

그렇다면 클라이언트가 주고받은 더미데이터들을 혼합해 임시키를 만들어 서버의 공개키로 암호화해 서버로 보내고 서버에서는 서버의 개인키로 복호화를 하고나서 이를 사용해 대칭키를 만듭니다. 그렇다면 이 대칭키는 비대칭키의 방식을 통해 공유되었기 때문에 안전하고 또한 대칭키이므로 부담이 적게 사용할 수 있습니다.



### CORS에 대해 설명해주세요

CORS에 대해 설명하기 전 SOP(Same origin policy)에 대해 말씀드리면 보안상의 이유로 프로토콜, 포트, 호스트가가 같아야만 통신이 가능하고 다르다면 브라우저에서 막는 정책이 있습니다.

SOP가 있는 이유로는 예를 들어 A, B 사이트간 통신이 된다면 B사이트에서 A사이트의 정보들을 저장해놓은 쿠키들을 탈취할 수 있기 때문입니다. 

그러나 저희가 웹 개발을 할때 vue에서는 8080, spring 에서는 9000번 포트를 사용하는 것과 같이 주소가 달라질 때가 있습니다. 이럴 때 CORS(Cross origin Resource sharing)을 통해 Spring과 vue가 통신이 가능하게 합니다.

CORS란 교차 출처 리소스 공유로 추가 HTTP 헤더를 사용해 다른 출처를 허용해주는 것으로 방법 중 서버와 요청을 보내는 방법으론 3가지가 있습니다.

첫 번째론 simple request로  GET, POST, HEAD 메서드와 특정된 헤더와 content type일땐 가능한 요청으로 content-type에 application/json 방법이 없기 때문에 실제로 많이 사용되지는 않는 방법입니다.

두 번째론 웹 개발시 가장 많이 나던 에러 중 하나인 prefilight request로 prefilight request는 요청을 보내기전 option 메서드를 통해 확인 요청을 보내고 확인을 받으면 요청을 보내는 방법이 있습니다. 토큰을 담아 같이 요청을 보내면 simple request에서 자동으로 preflight request로 변경되 요청을 보내기 때문에 가장 많이 쓰이는 요청 중 하나입니다. preflight request가 중요한 이유로는 사전작업이 있다는 점입니다. simple request에서는 물론 메서드로 막아놓은 상태이긴 하지만 DELETE 메서드를 보내 서버에서 지우고 클라이언트에게 돌려줄 때 브라우저에서 막아 CORS 에러가 발생하지만 Prefilight request는 사전작업이기 때문에 이런 불상사를 대비할 수 있습니다.

세 번째론 Credentail Request로 쿠키를 담아 보내는 요청은 더 보안이 강화된 방법입니다. prefilight보다 더 보안이 강화된 방법으로 특정 URL과 True 조건을 무조건 명시해줘야만 가능한 특징이 있습니다.

CORS 문제를 해결하는 방법들을 정리하면. 

첫 번째로는 서버에서 요청받는 @CrossOrigin annotation 으로 주소를 개별 등록하거나 config 파일에서 전역 등록을 해주는 방법이 있습니다.

두 번째 방법으로는 프론트에서 프록시를 설정해 CORS 에러가 안 나도록 우회하는 것이 있지만 로컬환경에서만 가능하기 때문에 서버에서 설정해주는 것이 더 좋은 방법이라고 볼 수 있습니다. 마지막으로 크롬 extension을 설치해 우회할 수 있지만 보안상 권장되지 않습니다.



### Forward Proxy와 Reverse Proxy에 대해 설명해주세요

프록시 서버란 해석하면 중개하는 서버로 프록시의 장점들론 크게 4가지가 있습니다.

첫 번째론 Vue에서 프록시 서버로 spring 을 설정해주면 브라우저에서 vue로 요청하고 spring에 가서 브라우저에 응답을 줄 때 spring 이 아니라 vue가 reverse proxy 서버처럼 응답을 대신해줘 브라우저의 CORS 에러를 방지해줘 개발을 편하게 진행해줄 수 있습니다.

두번째론 cors 뿐 아니라 origin 서버가 거리가 먼 해외에 있을 때 국내에 proxy 캐시 서버가 있으면 origin server로 까지 요청을 안보내고 국내의 proxy 캐시 서버로만 보내서 더 빨리 받아올 수 있다는 점이 있습니다.

 세 번째론 프록시 서버는 캐싱을 통해서 서버와 클라이언트의 부담을 줄여줄 수 있고 마지막으론 로드밸런싱을 통해 서버의 부담을 줄여줄 수 있습니다.

Forward Proxy: 포워드 프록시의 포워드는 전달해준다의 forward로

**클라이언트 -> 포워드 프록시 서버 -> 인터넷 -> 서버**

클라이언트 A가 인터넷에 접근할 때 직접 접근하는게 아니라 Forward Proxy 서버로 요청을 보내고 프록시서버에서 인터넷에 연결해 서버로 요청값을 받아와 클라이언트에게 응답해줄 수 있습니다.

이런 특징을 통해서 Forward Proxy는 두 가지의 장점이 있습니다.

첫 번째로 클라이언트 B가 A와 같은 요청을 보냈을 때 Forward Proxy에는 데이터 cache 가 이미 있으므로 인터넷과 서버까지 갈 필요없이 바로 클라이언트에게 응답해줘 성능을 향상시킬 수 있다는 장점이 있습니다.

장점으로 cache를 자주 사용하는 데이터라면 인터넷에 요청을 보내지 않고 프록시 서버에서 바로 client로 전달할 수 있기 때문에 성능향상이 가능합니다.

두 번째로 서버는 클라이언트가 아니라 프록시서버로부터 요청을 받기 때문에 프록시 서버의 ip로 받고 어느 클라이언트가 보냈는지 모르기 때문에 클라이언트 입장에서 익명성이 보장됩니다.

보통, 정해진 사이트들만 프록시 서버에서 연결할 수 있게 해줄 수 있어 기업의 인트라넷에서 많이 사용됩니다.



**클라이언트 -> 인 -> 리 -> 서**

Reverse Proxy:  리버스 프록시는 Forward Proxy와 다르게 

클라이언트가 요청을 보내면 곧바로 인터넷(WAS)으로 요청을 보내고 인터넷에서 Reverse Proxy를 통해 Server로 전달이 되고 서버에서 데이터를 받아와 클라이언트에게 응답을 해줍니다.

리버스 프록시의 장점으론 3가지가 있습니다.

첫 번째로 서버는 주로 제공해주는 데이터를 reverse proxy에 캐싱해놓을 수 있어 서버의 부담을 덜어줄 수 있습니다.

두 번째론 클라이언트는 내부서버에 대해 정보는 모른 채 필요한 데이터들만 리버스 프록시로부터 리버스 프록시가 서버인거로 인지해 받기 때문에 서버의 데이터거 보호된다는 장점이 있습니다.

마지막으론 Reverse proxy가 로드 밸런싱의 역할을 해 효율적으로 관리해줄 수 있습니다.

vue가 spring의 리버스 프록시 역할으 해준다 볼 수 있습니다.

cf) 로드 밸런싱: 서버는 큰 거 하나 쓰는것보다 작은 거 여러개 쓰는게 더 효율적인데 이 때 작은 서버들의 용량이 효율적으로 관리되게 도와주는게 로드밸런서!







### 쿠키, 세션, 캐시, JWT 토큰과 로그인에 대해 설명해주세요

우선 쿠키와 세션이 사용되는 이유로는 HTTP 특징안 Connectless, stateless 로 서버는 제가 로그인을 했어도 그 사실을 기억하지 못한다는 점에서 문제가 생깁니다.

이 문제점을 해결하기 위해 클라이언트가 로그인을 하고 서버에서 DB에 아이디, 비밀번호를 저장하고 그대로 서버에 돌려줘 클라이언트에 주면 보안에 문제가 생깁니다.

그렇기 때문에 서버에서 저라는 로그인한 user와 session id로 구성된 쿠키를 클라이언트에게 줍니다. 클라이언트는 쿠키를 브라우저에 저장해 이후 서버에 http 요청을 보낼때마다 쿠키를 같이 전달해 서버가 상태를 기억할 수 있게 합니다. 쿠키는 대개 팝업 제거, 새로 고침 시에 장바구니에 담아놓은 물건이 그대로 있는 것과 같은 정보로 갈취당해도 문제가 없는 데이터를 주로 저장합니다.

그 외의 중요한 민감한 정보들을 서버안에서 세션으로 관리합니다. 그러나 세션은 사용자가 많아질수록 메모리에 부담이 되므로 자주 사용되는 데이터는 캐시로 임시로 저장해 서버의 부담을 줄여줘야하거나 물론 그럴 일은 없어야 하겠지만 서버가 꺼지면 세션 정보가 날라간다는 단점이 있습니다. 또한 서비스가 성공해서 서버를 확장해야한다면 여러개의 서버 중 어느 특정 서버 A에 세션을 저장했지만 서버 B에 요청을 보내는 문제들이 생길 수 있습니다. 이 문제들을 해결하기 위해선 Session 들만 저장하는 session storage를 따로 만들어 저장해야하는 비용이 발생합니다.

이런 단점을 보완하기 위해 데이터를 저장하지 않고 직접 들고다니는 토큰방식인 JWT가 나왔습니다. 

JWT는 json web token으로 json 형태의 token으로 Authorization(인증)과 정보교환에 사용됩니다.

JWT는 header, payload, verify signature로 이루어져 있어 header는 암호화 알고리즘 방법과 type에 대한 정보가 있고 payload는 entity, 주로 user에 대한 정보를 디코딩하면 볼 수 있고 마지막으로 중요한 verify signature 부분은 encoding 된 header와 payload 부분과 256bit, 즉 32글자의 Secret key를 함께 HS 256 암호화 알고리즘을 통해 생성합니다.

JWT의 장점은 세션은 stateful해 서버의 상태에 영향을 받지만 토큰은 데이터, 정보를 직접 들고다녀 서버의 상태에 영향을 안 받는 Stateless 한다는 점이며 또한 이런 확장성을 통해 많은 회사가 oauth를 통해 소셜로그인을 jwt를 발급해 제공해줍니다.

Oauth2 소셜로그인을 카카오를 예시로 들면 

1. 우선 카카오 developer 홈페이지에서 접근하려는 url과 로그인 성공 및 실패 시 redirect url 을 설정해줍니다.
2. 카카오에  authorization GET 요청을 보내 동의하고 시작하기를 하면 토큰 발급을 위한 인가코드를 받습니다.
3. 받은 인가코드와 로그인 한 정보들을 통해 jwt, access, refresh 를 발급해줍니다.

이렇게 서버의 확장성이나 소셜 로그인과 같이 jwt는 편리하지만 단점도 있습니다.

jwt는 세션과 달리 중복로그인 못 막거나 JWT의 헤더와 Payload 부분은 base64 방식으로 인코딩 된거라 토큰을 탈취하면 사용자의 정보를 토큰을 디코딩해 볼 수 있습니다. 그러나 실제 signature key 에 256bit secret key가 없으니 토큰을 조작할 수 없고 또한 토큰의 유효기간을 가진 access, refresh token 들을 같이 활용해 계속 token을 재발급 해주는 방법으로 보안을 신경써주고 있습니다.



### 캐시 및 작동방법에 대해 설명해주세요.

서버에서 특정 리소스(이미지)를 받고나서 일정 시간안에 다시 같은 리소스를 접근할 때 또 보기 위해서 네트워크로 다시 전송 받으면 속도와 용량 측면에서 비효율적이라 클라이언트가 저장을 해놓고 보면 서버와 클라이언트 모두에게 효율적입니다. 

만약 캐시 유효시간이 지났고 서버가 그 기간동안 데이터가 변경된 상황이면 서버에서 새로 다운받아와야하지만 서버에서 데이터 변경이 일어나지 않았는데 새로 받아오는건 비효율적입니다.

그렇기 때문에 캐시의 검증헤더 last modified나 Etag를 통해 조건부 요청을 해줍니다.

저장한 이미지의 캐시를 보면 데이터의 최종 수정일 정보(last modified)가 같이 있는데 서버 데이터의 최종 수정일을 확인해 변경되지 않았다면 캐시의 데이터를 사용해도 괜찮으므로 서버에서 304 Not Modified를 body가 없는 응답을 클라이언트에 주고 클라이언트는 캐시를 사용합니다. 만약 데이터가 변경 됬으면 서버에서 200과 body를 함께 응답으로 줍니다. 







### RESTFUL API에 대해 설명해주세요

api는 말 그대로 interface로 소통하는 것인데 Restful 하다라는 건 저 혼자 뿐 아니라 다른 개발자들도 URI를 보고 어떤 기능을 하는 URI인줄 알 수 있도록 하는 것입니다.

일반적으로 동사는 제외하고 저희가 관리하는 자원들의 명사들로 URI를 관리하는게 최고의 방법이긴 하지만 현실적으로 주문하는 것과 같은 동적인 부분도 필요할 때가 많아서 개발자들간의 협의를 통해 정해야 할 것 같습니다.





### 웹서버와 WAS에 대해 설명해주세요(정적이미지를 받아오는 것도)

웹서버는 HTTP를 기반으로 동작하며 정적 리소스를 제공하는 서버로 Apache, Nginx가 있습니다.

웹서버는 특정 폴더나 디렉토리에 정적 파일들인 HTML, CSS, JS파일들을 넣어주면 외부에서 접근 가능하게 해주며 Vue.js 같은 경우 build 해주면 외부에서 접근 가능한 dist 폴더가 있습니다.

WAS 또한 HTTP 기반으로 동작하며 Web Server와 차이는 애플리케이션의 로직을 수행할 수 있어 동적인 HTML이나 REST API를 제공할 수 있으며 톰캣, Jetty 등이 있습니다.

즉 둘의 차이점은 웹서버는 정적 리소스 제공이며 WAS는 애플리케이션 코드를 실행하는데 더 특화되있다 볼 수 있습니다.

일반적인 웹시스템 구성은 WAS 앞에 웹서버가 있어 정적인 파일들은 웹서버가 해결해주고 만약 WAS가 에러가 나도 웹서버를 통해 에러페이지를 보여줄 수 있어 WAS 부담이 덜 합니다.

WAS앞에 웹서버가 있는 이유로는 다음과 같이 2가지가 있습니다.

1. 웹서버인 Nginx에서 정적인 파일 제공 뿐 아니라 리버스 프록시 기능이 있어 서버에 대한 정보는 유출되지 않고 데이터만 제공가능하며 로드 밸런싱 기능이 있어 톰캣의 업무 분담에 효율적입니다. 또한 웹서버의 Reverse Proxy는 서버에서의 캐쉬로 서버에서 자주 사용되는 데이터들을 캐시로 저장해 서버의 부담을 줄여줍니다.
2. WAS에 문제가 생겨도 Web server에서 에러페이지를 보여줄 수 있어 WAS 부담이 덜 합니다.

cf) 같은 사이트를 운영할 때 여러개의 톰캣(WAS)을 돌리는 이유는 업데이트를 할 때 하나의 톰캣이 작동을 못할 때 다른 톰캣들이 작동을 해줄 수 있기 때문입니다.



스프링부트를 배포하기 위해선 스프링을 톰캣이 들어있는 jar 파일로 빌드해 배포하면 됩니다.

클라이언트가 이미지데이터를 받아올 때 보통 WAS 앞에 웹서버가 있어 웹서버로부터 받아옵니다.



### Polling, Long Polling?

Polling 이란 클라이언트가 일정한 주기로 계속 서버에 요청을 보내 답을 받아오는 방법으로 데이터가 없더라도 받아오는 등 불필요한 서버 부담이 큰 방법! ex) 채팅 앱에 나한테 누가 보낸 채팅이 없어도 계속 받아오고 만약 있어도 정해진 시간이 되기전까지 못받아옴

Long polling 이란 클라이언트가 서버를 요청보내고 서버가 응답보낼게 있을 수 있으니 서버에서 오래 대기타다가 오는 것

facebook chat 을 보면 채팅을 켜놓으면 가만히 있어도 일정 시간마다 응답이오는걸 봐서 Long Polling인듯?

웹 기준: polling or 웹소켓

앱은 또 다름!! mqtt facebook chat?? 모르겟ㄴ에~~



### 웹소켓과 소켓에 대해 설명해주세요

웹 소켓이란 두 프로그램간의 메세지를 교환하기 위한, 즉 클라이언트와 서버간의 메세지를 교환하기 위한 통신 방법 중 하나입니다.

웹소켓 이전엔 polling, long polling 등과 같이 서버에게 일정 주기로 요청을 보내는 방식이지만 실시간 통신방식에서는 언제 통신이 발생할지 예측이 불가능해 불필요한 요청과 응답들이 생기곤 했습니다. polling 과 같은 방법들은 결국 비연결성 특징을 가지는 HTTP 통신이기 때문에 불필요한 요청 및 헤더가 크다는 단점이 있습니다.

이런 단점들을 극복하기 위해 나온 웹 소켓은 클라이언트들과 서버가 연결되있어 클라이언트들이 같은 채팅방에 접속하면 같은 웹소켓 서버로 접속한거라 한 명의 클라이언트가 웹소켓 서버로 메세지를 보내면 웹소켓 서버가 다른 클라이언트들에게 메세지를 보내는 방식입니다.

웹소켓의 동작방식은 첫 번째로 클라이언트와 서버를 연결할 때는 HTTP GET 요청을 보냅니다, 이 때 보내는 GET 요청에는 websocker으로 업그레이드하기 위한 명령어와 security websocket key를 보내줘 cookie와 같이 사용자 인증을 해줍니다.  이후 응답으로 101 Switching protocol 이 오며 웹소켓이 연결된 것을 확인할 수 있습니다

그렇다면 프로토콜이 http, https에서 ws(80)와 wss(443)으로 변경되며 이후 frame의 집합인 텍스트나 메세지를 인코딩해 서로간의 통신을 하고 통신이 끝나면 연결을 종료하게 됩니다.

기존의 HTTP 통신과의 차이점으론 최초 접속이후론 Http 프로토콜을 사용하지 않는것이 있습니다.



웹 소켓의 특징으론 첫 번째로 일반적인 Http 통신은 클라이언트가 요청을 보내면 서버가 응답을 보내는 단뱡향 통신이지만 웹소켓은 양방향 통신입니다. 즉, 클라이언트와 서버가 서로에게 원할 때 데이터를 주고 받을 수 있습니다.

두 번째 특징으론 실시간 네트워킹으로 연속된 데이터를 빠르게 노출시켜야 할 때, 예를 들면 채팅, 주식, 비디오 데이터 서비스등에서 사용됩니다.



웹소켓은 HTML5 이후에 나온 기술로 HTML5 이전의 서비스에서는 웹소켓을 사용할 수 없어 웹소켓처럼 사용할 수 있도록 해주는 JS 라이브러리입니다. 소켓은 JS를 사용해 브라우저 종류에 상관없이 실시간 웹을 구현해 브라우저와 웹 서버의 종류를 파악해 가장 적합한 기술을 채택해주는 방식입니다. 그러나 웹소켓은 문자열을 주고받기만 그 이상의 역할은 못하기 때문에 sub protocol로 stomp를 사용해 클라이언트와 서버가 통신하는 메세지의 유형, 형식, 내용들의 분류를 도와줄 수 있습니다.



## cf) webRTC 란?

웹소켓에 사용자들이 너무 많으면 메세지를 클라이언트에게 받아서 다시 전달해주려면 웹소켓 서버에 부담이 많이 감 + 서버가 내려가면 사용 불가능함.

이러한 문제점들로 브라우저를 서버에 연결하는게 아니라 브라우저들끼리 연결하자는 생각으로 나온게 webRTC(P2P 방법)

또한 웹소켓은 텍스트만 전송가능했지만 webRTC는 텍스트, 영상, 음악 다 리얼타임으로 전송 가능

장점으론 서버를 거치지 않으므로 더 빠름

그러나 webRTC는 하나의 방에 사람들이 1000명 있다면 999명에게 내가 올린 파일을 업로드 해줘야하는 것과 같이 확장성에는 문제가 있음

webRTC는 JS 기반임!





### 비동기 프로그래밍에 대해 설명해주세요

비동기적으로 작동하는 것 중 대표적인 언어로 JS가 있습니다.

JS는 Single thread, 즉 이벤트를 처리하는 Call stack이 하나이지만 Web API, Task queue가 있어 비동기적으로 처리할 수 있습니다.

예를 들어 요청들이 여러개가 있을 때 하나의 요청이 setTimeout과 같이 일정 시간을 대기해야만 하는 요청이 있다면 동기적 프로그래밍은 해당 시간동안 명령들이 대기하지만 JS에서는 대기하는 요청은 Web API로 가서 대기하며 그 다음의 요청들이 Call stack에 먼저 들어가 수행하게 됩니다.

이후 일정시간이 다 차면 web api의 요청이 Task queue에 들어가 call stack이 빌 때까지 대기하고 비게 된다면 call stack 에 들어가 실행됩니다.

비동기 프로그래밍의 필요한 부분만 데이터를 다운받아 사용하면 되기 때문에 화면전환이 필요없는 구글의 이메일, 구글맵등과 같이 자연스러운 변경에 사용됩니다.

다만 비동기의 단점으론 순서가 보장이 되지 않아 만약 서버에서 토큰을 받아와토큰을 통해 기능을 사용해야 하는 순서가 중요한 작업들에서 문제가 생길 수 있어 순서를 보장해주는 방법 3가지가 있습니다.

첫 번째론 콜백함수로 함수내부에 함수를 작성하는 것으로 이벤트가 끝나야 다음 함수를 처리하는 방법이지만 콜백지옥이라는 말이 나올정도로 코드가 길어지면 가독성이 안좋습니다.

두 번째 방법으로 Promise 객체로 .then chaninig 순서를 보장해주며 axios 요청도 promise 기반의 요청이며 콜백함수보다 가독성이 좋습니다.

세 번째 방법으론 async await가 있습니다. async 는 일반적인 함수를 promise 객체로 return 해주며 await는.then 과 같이 동기적으로 기다려주는 역할을 해줘 Promise 방법을 일반적인 동기적인 코드 스타일로 변경해줄 수 있습니다.



cf) 호이스팅이란 var 변수와 함수선언이 제일 위로 올라가는 것입니다



### CSR & SSR

우선 MPA는 multi page application 으로 매번 화면이 바뀔때마다 새로운 html을 서버로부터 받아와 전환 시마다 화면이 깜빡이게 되 AJAX 비동기 요청이 나오고 나서 화면 깜박임이 없고 원하는 부분만 동적으로 바꿀 수 있는 SPA 방식이 더 많이 선호하는 추세입니다.

SPA는 일반적으로 렌더린 방식으로 CSR 이며 MPA는 렌더링 방식으로 SSR 을 사용합니다. SPA는 처음에 웹사이트에 접속했을 때 필요한 데이터를 전부 다운 받고 클라이언트가 정보를 요청 했을 시 다운받은 데이터를 브라우저에서 만들어주는 CSR, MPA는 매번 서버에서 보내주기 때문에 SSR을 사용하게 됨

React, vue, angular -> CSR

PHP, JSP -> SSR

CSR 동작방식은 클라이언트가 브라우저에 방문하면 브라우저에서 서버에 데이터를 요청합니다. 서버는 브라우저에 뼈대 HTML과 JS가 연결된 링크를 전달해줘 브라우저에서 JS 링크를 통해 JS를 다운받아 동적 DOM을 생성해줍니다. CSR의 단점으론 브라우저에서 JS를 다운받고 동적 DOM을 생성해줘야하므로 초기 로딩속도가 느리다는 단점이 있습니다. 그러나 초기 이후엔 필요한 부분의 데이터만 요청을 해 바꿔주면 되므로 더 빠르다는 장점이 있습니다. 서버의 부하가 적어 요새 같이 핸드폰, 컴퓨터 개인용 기기들이 많이 발전됬을 때 적절한 방법이라는 생각!

그러나 브라우저가 가진 웹크롤러는 Html을 읽어 검색 색인을 만드는데 처음에 전달받은 html은 빈 상태라 검색엔진이 색인할 컨텐츠가 안보여서 검색엔진최적화(SEO)에 불리하다는 단점이 있슴!! 구글봇은 CSR도 검색엔진에서 읽을 수 있지만 아직 발전중인 상태..

SSR은 클라이언트가 브라우저에 방문하면 브라우저에서 서버로 데이터를 요청하고 서버에서는 렌더링 준비를 끝낸 HTML, JS code를 브라우저에게 전달해줍니다. 브라우저에서는 HTML을 바로 띄우고 JS code를 다운받아 html에 js 로직을 연결만 하면 됨!! html에 데이터가 이미 담긴 상태로 브라우저에 전달되기 때문에 SEO 에 유리하다는 장점 & 초기 구동속도는 빠름 But 처음에 화면에 보여서 클릭을 해도 아직 js code와 html 연결이 안된 상태면 브라우저 구동이 안될 수 있다는 단점 존재. 즉 보이는 것과 실제 작동되는 시간의 gap이 존재(TTV != TTI Time to View != Time to Interaction)

그렇다면 CSR이 요즘 대세니 CSR이 무조건 더 좋나?

CSR의 단점이 있으니 단점을 보완하는 방법으로 

첫 번째로 초기 로딩 속도가 느린것은 code splitting, tree-shakine, chunk 분리와 같은 방법으로 크기를 줄여 초기 로딩속도 개선!

두 번째론 SEO 문제로 pre-rendering, 라이브러리 웹팩 플러그인을 사용해 미리 html 파일을 생성해놔 크롤러에게 전달해주는 방식!!

세번째로 SSR/SSG(static site Generator) 도입! React, Angular, vue 등 각각 라이브러리로 페이지별로 SSR, SSG 선택해 도입 가능

즉 정리하면 서비스의 성격에 따라 CSR, SSR 방법 선택

고객의 데이터를 보호하는 서비스면 SEO가 필요없으니 CSR이 더 적합할 수 있고

많은 사람들에게 똑같은 화면을 노출되어야 하는 서비스면 SSR, SSR에서 업데이트가 거의 없다면 SSG,

모든 게 중요하면 CSR+SSR 합친 Universal Rendering 채택!



XSS, XSRF 보안에 대해 아시나요

XSS의 공격 방지로 HttpOnly 가 있으며 자바스크립트로 쿠키에 접근 불가능하고 HTTP 전송에서만 쿠키 사용가능합니다.

XSRF의 공격 방지로 Same Site가 있으며 요청 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키를 전송합니다.



### 객체지향 프로그래밍이란?

 



### 함수형 프로그래밍이란?

